#다이나믹 프로그래밍 :중복된하위문제+최적부분구조
#이전에 사용햇던 답이 필요하면 재활용하는것
#메모이제이션 : 하향식접근법/배열에기록하여 사용/
#타뷸레이션 : 상향식접근법/
#탑다운방식(메모이제이션) : 재귀 방식 /간결,가독성/필요한값만-메모리증가
    #큰문제를 해결하기위해 작은부분의 문제를 재귀적으로 나누어가며 해결
#바텀 업 방식(타뷸레이션):반복문 /필요없는것도 구함- 메모리사용적음
    # 반복문을 사용하여

#피보나치수열탑다운방식

class Solution:
    def fib(self, n:int) -> int:     # 리스트: memo[0,1,0,0,0,0,0,0]
        def top_down(num:int, memo:list[int]) -> int:
            #2-2 이거 6넣고 5+4라고햇으니 5가 다시들어가서 함수작동됨
            #탑다운방식: 계산이 필요한 순간,계산후 결과를저장해
            #재귀를 통해 이전에 계산한 값들을 활용!간결하고 가독성이 좋다
            if num <= 1: #육넣으면해당안됨
                return num
            #2-1이거 6넣으면 인덱스 6자리는 0임 이게 탑다운방식(5,메모)+탑다운방식 (4,메모)
            elif memo[num] == 0: #이거 인덱스자리임 자리안에잇는수가 0인가
                #피보나치수열 작은문제
                memo[num] = top_down(num-1, memo) + top_down(num-2, memo)
            # else:
            return memo[num]
        #memoization
        memo = [0,1] + [ 0 ] * (n - 1) #0 일단초기화
        return top_down(6,memo) #여기가 육이들어감

s = Solution()
print(s.fib(6)) #큰문제

# 6이면  memo = [0,1] + [ 0 ] * (n - 1)
#  memo[0,1,0,0,0,0,0,0]